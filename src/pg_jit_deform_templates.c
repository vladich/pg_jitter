/*-------------------------------------------------------------------------
 *
 * pg_jit_deform_templates.c
 *		Pre-compiled deform functions for common fixed-width column patterns.
 *
 * GENERATED FILE â€” do not edit by hand.
 * Generated by tools/gen_deform_templates.py
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "access/htup_details.h"
#include "executor/tuptable.h"

#include "pg_jit_deform_templates.h"


static void jit_deform_i4(TupleTableSlot *slot);
static void jit_deform_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i4_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i4_i8_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i4_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i4_i8_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i4_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i4_i8(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i8_i4(TupleTableSlot *slot);
static void jit_deform_i8_i8_i8_i8_i8(TupleTableSlot *slot);
static void jit_deform_i1(TupleTableSlot *slot);
static void jit_deform_i2(TupleTableSlot *slot);
static void jit_deform_i1_i1(TupleTableSlot *slot);
static void jit_deform_i1_i2(TupleTableSlot *slot);
static void jit_deform_i2_i1(TupleTableSlot *slot);
static void jit_deform_i2_i2(TupleTableSlot *slot);


static void
jit_deform_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 1))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
		default:
			break;
	}

	slot->tts_nvalid = 1;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 4;
	else
		hslot->off = 4;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 1))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
		default:
			break;
	}

	slot->tts_nvalid = 1;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 8;
	else
		hslot->off = 8;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 8;
	else
		hslot->off = 8;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 16;
	else
		hslot->off = 16;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 12;
	else
		hslot->off = 12;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 16;
	else
		hslot->off = 16;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 12;
	else
		hslot->off = 12;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 16;
	else
		hslot->off = 16;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 20;
	else
		hslot->off = 20;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 16;
	else
		hslot->off = 16;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 20;
	else
		hslot->off = 20;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 3))
	{
		slot_getsomeattrs_int(slot, 3);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
		default:
			break;
	}

	slot->tts_nvalid = 3;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 16;
	else
		hslot->off = 16;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 20;
	else
		hslot->off = 20;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 20;
	else
		hslot->off = 20;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 4))
	{
		slot_getsomeattrs_int(slot, 4);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
		default:
			break;
	}

	slot->tts_nvalid = 4;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 20;
	else
		hslot->off = 20;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 16);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i4_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 4));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 8);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 32));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 36;
	else
		hslot->off = 36;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 28));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 32));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 36;
	else
		hslot->off = 36;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i4_i8_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int32)(*(int32 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 24;
	else
		hslot->off = 24;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 12));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 16);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 28));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 32));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 36;
	else
		hslot->off = 36;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i4_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int32)(*(int32 *)(tp + 8));
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 28;
	else
		hslot->off = 28;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 20));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 24);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 32));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 36;
	else
		hslot->off = 36;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i4_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = (Datum)(int32)(*(int32 *)(tp + 16));
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i4_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 28));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 32;
	else
		hslot->off = 32;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i4_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = (Datum)(int32)(*(int32 *)(tp + 24));
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i8_i4(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = (Datum)(int32)(*(int32 *)(tp + 32));
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 36;
	else
		hslot->off = 36;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i8_i8_i8_i8_i8(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 5))
	{
		slot_getsomeattrs_int(slot, 5);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = *(Datum *)(tp + 0);
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = *(Datum *)(tp + 8);
			isnull[1] = false;
			/* FALLTHROUGH */
		case 2:
			values[2] = *(Datum *)(tp + 16);
			isnull[2] = false;
			/* FALLTHROUGH */
		case 3:
			values[3] = *(Datum *)(tp + 24);
			isnull[3] = false;
			/* FALLTHROUGH */
		case 4:
			values[4] = *(Datum *)(tp + 32);
			isnull[4] = false;
		default:
			break;
	}

	slot->tts_nvalid = 5;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 40;
	else
		hslot->off = 40;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i1(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 1))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int8)(*(int8 *)(tp + 0));
			isnull[0] = false;
		default:
			break;
	}

	slot->tts_nvalid = 1;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 1;
	else
		hslot->off = 1;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i2(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 1))
	{
		slot_getsomeattrs_int(slot, 1);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int16)(*(int16 *)(tp + 0));
			isnull[0] = false;
		default:
			break;
	}

	slot->tts_nvalid = 1;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 2;
	else
		hslot->off = 2;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i1_i1(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int8)(*(int8 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int8)(*(int8 *)(tp + 1));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 2;
	else
		hslot->off = 2;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i1_i2(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int8)(*(int8 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int16)(*(int16 *)(tp + 2));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 4;
	else
		hslot->off = 4;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i2_i1(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int16)(*(int16 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int8)(*(int8 *)(tp + 2));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 3;
	else
		hslot->off = 3;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

static void
jit_deform_i2_i2(TupleTableSlot *slot)
{
	HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;
	HeapTupleHeader tup = hslot->tuple->t_data;
	Datum      *values = slot->tts_values;
	bool       *isnull = slot->tts_isnull;
	char       *tp;
	int         nvalid = slot->tts_nvalid;

	if (unlikely(tup->t_infomask & HEAP_HASNULL))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	if (unlikely(HeapTupleHeaderGetNatts(tup) < 2))
	{
		slot_getsomeattrs_int(slot, 2);
		return;
	}

	tp = (char *) tup + tup->t_hoff;

	switch (nvalid)
	{
		case 0:
			values[0] = (Datum)(int16)(*(int16 *)(tp + 0));
			isnull[0] = false;
			/* FALLTHROUGH */
		case 1:
			values[1] = (Datum)(int16)(*(int16 *)(tp + 2));
			isnull[1] = false;
		default:
			break;
	}

	slot->tts_nvalid = 2;

	if (unlikely(slot->tts_ops == &TTSOpsMinimalTuple))
		((MinimalTupleTableSlot *) slot)->off = 4;
	else
		hslot->off = 4;

	slot->tts_flags |= TTS_FLAG_SLOW;
}

const DeformTemplate jit_deform_templates[] = {
	{ 0x0000, jit_deform_i1 },
	{ 0x0001, jit_deform_i1_i1 },
	{ 0x0008, jit_deform_i2 },
	{ 0x0009, jit_deform_i2_i1 },
	{ 0x0010, jit_deform_i4 },
	{ 0x0018, jit_deform_i8 },
	{ 0x0021, jit_deform_i1_i2 },
	{ 0x0029, jit_deform_i2_i2 },
	{ 0x0051, jit_deform_i4_i4 },
	{ 0x0059, jit_deform_i8_i4 },
	{ 0x0071, jit_deform_i4_i8 },
	{ 0x0079, jit_deform_i8_i8 },
	{ 0x0152, jit_deform_i4_i4_i4 },
	{ 0x015A, jit_deform_i8_i4_i4 },
	{ 0x0172, jit_deform_i4_i8_i4 },
	{ 0x017A, jit_deform_i8_i8_i4 },
	{ 0x01D2, jit_deform_i4_i4_i8 },
	{ 0x01DA, jit_deform_i8_i4_i8 },
	{ 0x01F2, jit_deform_i4_i8_i8 },
	{ 0x01FA, jit_deform_i8_i8_i8 },
	{ 0x0553, jit_deform_i4_i4_i4_i4 },
	{ 0x055B, jit_deform_i8_i4_i4_i4 },
	{ 0x0573, jit_deform_i4_i8_i4_i4 },
	{ 0x057B, jit_deform_i8_i8_i4_i4 },
	{ 0x05D3, jit_deform_i4_i4_i8_i4 },
	{ 0x05DB, jit_deform_i8_i4_i8_i4 },
	{ 0x05F3, jit_deform_i4_i8_i8_i4 },
	{ 0x05FB, jit_deform_i8_i8_i8_i4 },
	{ 0x0753, jit_deform_i4_i4_i4_i8 },
	{ 0x075B, jit_deform_i8_i4_i4_i8 },
	{ 0x0773, jit_deform_i4_i8_i4_i8 },
	{ 0x077B, jit_deform_i8_i8_i4_i8 },
	{ 0x07D3, jit_deform_i4_i4_i8_i8 },
	{ 0x07DB, jit_deform_i8_i4_i8_i8 },
	{ 0x07F3, jit_deform_i4_i8_i8_i8 },
	{ 0x07FB, jit_deform_i8_i8_i8_i8 },
	{ 0x1554, jit_deform_i4_i4_i4_i4_i4 },
	{ 0x155C, jit_deform_i8_i4_i4_i4_i4 },
	{ 0x1574, jit_deform_i4_i8_i4_i4_i4 },
	{ 0x157C, jit_deform_i8_i8_i4_i4_i4 },
	{ 0x15D4, jit_deform_i4_i4_i8_i4_i4 },
	{ 0x15DC, jit_deform_i8_i4_i8_i4_i4 },
	{ 0x15F4, jit_deform_i4_i8_i8_i4_i4 },
	{ 0x15FC, jit_deform_i8_i8_i8_i4_i4 },
	{ 0x1754, jit_deform_i4_i4_i4_i8_i4 },
	{ 0x175C, jit_deform_i8_i4_i4_i8_i4 },
	{ 0x1774, jit_deform_i4_i8_i4_i8_i4 },
	{ 0x177C, jit_deform_i8_i8_i4_i8_i4 },
	{ 0x17D4, jit_deform_i4_i4_i8_i8_i4 },
	{ 0x17DC, jit_deform_i8_i4_i8_i8_i4 },
	{ 0x17F4, jit_deform_i4_i8_i8_i8_i4 },
	{ 0x17FC, jit_deform_i8_i8_i8_i8_i4 },
	{ 0x1D54, jit_deform_i4_i4_i4_i4_i8 },
	{ 0x1D5C, jit_deform_i8_i4_i4_i4_i8 },
	{ 0x1D74, jit_deform_i4_i8_i4_i4_i8 },
	{ 0x1D7C, jit_deform_i8_i8_i4_i4_i8 },
	{ 0x1DD4, jit_deform_i4_i4_i8_i4_i8 },
	{ 0x1DDC, jit_deform_i8_i4_i8_i4_i8 },
	{ 0x1DF4, jit_deform_i4_i8_i8_i4_i8 },
	{ 0x1DFC, jit_deform_i8_i8_i8_i4_i8 },
	{ 0x1F54, jit_deform_i4_i4_i4_i8_i8 },
	{ 0x1F5C, jit_deform_i8_i4_i4_i8_i8 },
	{ 0x1F74, jit_deform_i4_i8_i4_i8_i8 },
	{ 0x1F7C, jit_deform_i8_i8_i4_i8_i8 },
	{ 0x1FD4, jit_deform_i4_i4_i8_i8_i8 },
	{ 0x1FDC, jit_deform_i8_i4_i8_i8_i8 },
	{ 0x1FF4, jit_deform_i4_i8_i8_i8_i8 },
	{ 0x1FFC, jit_deform_i8_i8_i8_i8_i8 },
};

const int jit_deform_templates_count = 68;

deform_template_fn
jit_deform_find_template(uint16 sig)
{
	int	lo = 0;
	int	hi = jit_deform_templates_count - 1;

	while (lo <= hi)
	{
		int		mid = (lo + hi) / 2;
		uint16	mid_sig = jit_deform_templates[mid].signature;

		if (mid_sig == sig)
			return jit_deform_templates[mid].fn;
		else if (mid_sig < sig)
			lo = mid + 1;
		else
			hi = mid - 1;
	}

	return NULL;
}
